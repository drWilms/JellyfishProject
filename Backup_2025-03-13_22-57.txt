Merged JellyfishProject Code (Generated on 2025-03-13_22-57) 
===================================================== 
======================================= 
File: src\main.cpp 
======================================= 
// werkt OK: fragment, fadein en fadeuit, disco

#include <Arduino.h>
#include "config.h"
#include <SD.h>
#include <SPI.h>
#include <AudioFileSourceSD.h>
#include <AudioGeneratorMP3.h>
#include <AudioOutputI2S.h>
#include <FastLED.h>
#include "JellyfishAudio.h" // Custom class with gain & audio level


CRGBArray<NUM_LEDS> leds;

// ======= Audio Configuration =======
#define BYTESPERSEC 16000
#define MP3_FILE "/test.mp3" // MP3 file on SD card root

// Global Audio Objects
AudioFileSourceSD *file;
AudioGeneratorMP3 *mp3;
AudioOutputI2SWithLevel *audioOutput;

// For fragment playback control
unsigned long fragmentStartTime = 0;
unsigned long fragmentDuration = 0; // in milliseconds
bool playingFragment = false;

// For LED updates 
void updateLEDs() {
  //  Serial.println("Updating LEDs...");
    FastLED.setMaxPowerInVoltsAndMilliamps(VOLTAGE, MAX_MILLIAMPS);
    int level = audioOutput->getAudioLevel();
    int brightness = map(level, 0, 5000, 10, 255);
    brightness = constrain(brightness, 10, 255);
    for (int i = 0; i < NUM_LEDS; i++) {
        leds[i] = CHSV(160, 255, brightness);
    }
    FastLED.show();
}

/***************************************************************************
 * Plays a fragment of the MP3 file.
 * @param filename The MP3 filename (with leading slash).
 * @param startSec The start time in seconds.
 * @param endSec   The end time in seconds.
 * @return true if playback started successfully.
 */
bool playFragmentMP3(const char *filename, unsigned long startSec, unsigned long endSec)
{
  // Stop current playback if any
  if (mp3 && mp3->isRunning())
  {
    mp3->stop();
  }
  if (file)
  {
    file->close();
    delete file;
    file = nullptr;
  }

  // Open the file
  file = new AudioFileSourceSD(filename);

  // For CBR MP3: calculate byte offset
  // Example: for 128 kbps, ~16,000 bytes per second.
  const unsigned long bytesPerSec = BYTESPERSEC;
  unsigned long startOffset = startSec * bytesPerSec;
  if (!file->seek(startOffset, SEEK_SET))
  {
    Serial.println("Seek failed!");
    return false;
  }

  // Restart the MP3 generator
  if (!mp3->begin(file, audioOutput))
  {
    Serial.println("MP3 playback failed to start!");
    return false;
  }

  // Calculate fragment duration in milliseconds
  fragmentDuration = (endSec - startSec) * 1000;
  fragmentStartTime = millis();
  playingFragment = true;

  Serial.printf("Playing fragment from %lu s to %lu s\n", startSec, endSec);
  return true;
}

void setup()
{
  Serial.begin(115200);
  delay(3000); // Allow hardware/Serial to initialize

  if (!SD.begin(SD_CS))
  {
    Serial.println("SD Card Mount Failed!");
    while (1)
      ;
  }
  Serial.println("SD Card Mounted!");

  // Initialize Audio Objects
  file = new AudioFileSourceSD(MP3_FILE);
  mp3 = new AudioGeneratorMP3();
  audioOutput = new AudioOutputI2SWithLevel();
  audioOutput->SetPinout(PIN_I2S_BCLK, PIN_I2S_LRC, PIN_I2S_DOUT);
  audioOutput->SetOutputModeMono(false);
  audioOutput->SetRate(44100);
  audioOutput->SetGain(1.0); // Use full volume

  // Initialize LED strip
  FastLED.addLeds<LED_TYPE, PIN_RGB, LED_RGB_ORDER>(leds, NUM_LEDS);
  FastLED.setMaxPowerInVoltsAndMilliamps(VOLTAGE, MAX_MILLIAMPS);
  FastLED.clear();
  FastLED.show();



  // Start playing a fragment (for example, from 10 sec to 20 sec)
  playFragmentMP3(MP3_FILE, 5, 15);
}

void loop()
{
  // Continue decoding if playback is running
  if (playingFragment && mp3 && mp3->isRunning())
  {
    mp3->loop();
  }
  else if (playingFragment)
  {
    // Playback finished naturally, or stopped
    Serial.println("Fragment playback ended.");
    playingFragment = false;
  }

  // Check if fragment duration has elapsed
  if (playingFragment)
  {
    unsigned long elapsed = millis() - fragmentStartTime;
    // If we've played longer than our fragment, stop playback.
    if (elapsed >= fragmentDuration)
    {
      Serial.println("Fragment duration reached. Stopping playback.");
      mp3->stop();
      playingFragment = false;
    }
  }

  // Update LEDs continuously
  updateLEDs();
  delay(10);
}

 
======================================= 
Library: lib\config 
======================================= 
======================================= 
File: lib\config\config.h 
======================================= 
/**
 * Jellyfish Project - Fully Restored Codebase with Timer Hierarchy
 * Version: 2025-03-07
 */

// ========================= config.h =========================
#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>
#include "config_secrets.h"

// === Pin Definitions ===
#define LED_PIN         2  // Built-in LED
#define PIN_RGB         4  // LED Data Out
#define PIN_LED         PIN_RGB
#define PIN_I2S_DOUT   14  // I2S Data
#define PIN_I2S_BCLK   13  // I2S Bit Clock
#define PIN_I2S_LRC    15  // I2S Left/Right Clock
#define PIN_SD_CS       5  // SD Card Chip Select

// === LED Configuration ===
#define NUM_LEDS 10
#define LED_TYPE WS2812    // Define LED type
#define LED_RGB_ORDER GRB  // Define RGB order

#define MAX_MILLIAMPS 2000
#define VOLTAGE 5

// === Timer Intervals ===
//#define SLOW_TIMER_INTERVAL   1000  // 1 second and above
//#define FAST_TIMER_INTERVAL    250  // 100ms - 999ms
//#define ULTRAFAST_TIMER_INTERVAL 50 // Below 100ms

// === Global Variables ===
extern int audioLevel;   // Stores real-time audio level
extern bool silentMode;  // True if LEDs should remain off
extern int brightness;   // LED brightness level



#define SDA           21
#define SCL           22
#define SD_CS          5
#define SPI_MOSI      23
#define SPI_MISO      19
#define SPI_SCK       18



#endif  // CONFIG_H 
======================================= 
File: lib\config\config_secrets.h 
======================================= 
#ifndef CONFIG_SECRETS_H
#define CONFIG_SECRETS_H

#define WIFI_SSID "keijebijter"
#define WIFI_PASSWORD "Helmondia'55"

#endif // CONFIG_SECRETS_H
 
======================================= 
File: lib\config\config.cpp 
======================================= 
#include "config.h"

// === Global Variables ===
int audioLevel = 0;
bool silentMode = false;
int brightness = 150;
 
======================================= 
Library: lib\JellyfishLEDs 
======================================= 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.h 
======================================= 
#ifndef JELLYFISHLEDS_H
#define JELLYFISHLEDS_H

#include <FastLED.h>
#include "config.h"

#define DEBUG 1
#define LOG(x) if (DEBUG) Serial.println(F(x))

class JellyfishLEDs {
public:
    CRGB leds[NUM_LEDS];

    JellyfishLEDs();
    void setSingleColor(int index, CRGB color);
    void updateLEDs();
};

#endif
 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.cpp 
======================================= 
#include "JellyfishQueue.h"

JellyfishQueue::JellyfishQueue() {}

void JellyfishQueue::enqueue(std::function<void()> task) {
    taskQueue.push(task);
}

void JellyfishQueue::enqueueDelayed(unsigned long delayMs, std::function<void()> task) {
    delayedTasks.push_back({millis() + delayMs, task});
}

void JellyfishQueue::processQueue() {
    while (!taskQueue.empty()) {
        auto task = taskQueue.front();
        taskQueue.pop();
        task();
    }

    unsigned long now = millis();
    auto it = delayedTasks.begin();
    while (it != delayedTasks.end()) {
        if (now >= it->first) {
            it->second();
            it = delayedTasks.erase(it);
        } else {
            ++it;
        }
    }
}
 
======================================= 
File: lib\JellyfishLEDs\keywords.txt 
======================================= 
 
// Updated: 2025-03-11 07:30:00 
JellyfishLEDs   KEYWORD1 
setSingleColor  KEYWORD2 
updateLEDs      KEYWORD2 
clearLEDs       KEYWORD2 
// END OF GPT UPDATE FILE 
 
======================================= 
Library: lib\JellyfishQueue 
======================================= 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.h 
======================================= 
#ifndef JELLYFISHQUEUE_H
#define JELLYFISHQUEUE_H

#include <Arduino.h>

class JellyfishQueue {
private:
    static const int MAX_SIZE = 100;
    char queue[MAX_SIZE];
    int front;
    int rear;
    int count;

public:
    JellyfishQueue();

    void add(char item);  // Renamed from enqueue
    char dequeue();
    void process();       // New function
    bool isEmpty() const;
    bool isFull() const;
    int size() const;

    // Java-style getters
    int getFrontIndex() const;
    int getRearIndex() const;
    int getCount() const;
};

#endif  // JELLYFISHQUEUE_H
 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.cpp 
======================================= 
#include "JellyfishQueue.h"

JellyfishQueue::JellyfishQueue() : front(0), rear(0), count(0) {}

void JellyfishQueue::add(char item) {
    if (!isFull()) {
        queue[rear] = item;
        rear = (rear + 1) % MAX_SIZE;
        count++;
    }
}

char JellyfishQueue::dequeue() {
    if (!isEmpty()) {
        char item = queue[front];
        front = (front + 1) % MAX_SIZE;
        count--;
        return item;
    }
    return '\0'; // Return null character if empty
}

void JellyfishQueue::process() {
    while (!isEmpty()) {
        Serial.print(dequeue());
    }
}

bool JellyfishQueue::isEmpty() const {
    return count == 0;
}

bool JellyfishQueue::isFull() const {
    return count == MAX_SIZE;
}

int JellyfishQueue::size() const {
    return count;
}

int JellyfishQueue::getFrontIndex() const {
    return front;
}

int JellyfishQueue::getRearIndex() const {
    return rear;
}

int JellyfishQueue::getCount() const {
    return count;
}
 
======================================= 
File: lib\JellyfishQueue\keywords.txt 
======================================= 
# Keywords for Jellyfish Project

# Class
JellyfishQueue    KEYWORD1

# Methods
add               KEYWORD2
dequeue           KEYWORD2
process           KEYWORD2
isEmpty           KEYWORD2
isFull            KEYWORD2
size              KEYWORD2
getFrontIndex     KEYWORD2
getRearIndex      KEYWORD2
getCount          KEYWORD2
 
======================================= 
Library: lib\JellyfishAudio 
======================================= 
======================================= 
File: lib\JellyfishAudio\JellyfishAudio.h 
======================================= 
#ifndef JELLYFISHAUDIO_H
#define JELLYFISHAUDIO_H

#include <Arduino.h>
#include <AudioOutputI2S.h>

class AudioOutputI2SWithLevel : public AudioOutputI2S {
public:
    AudioOutputI2SWithLevel();
    
    bool SetGain(float gain);
    float getCurrentGain() const;
    bool ConsumeSample(int16_t sample[2]);
    int getAudioLevel();

private:
    int audioLevel;
    float currentGain;
};

#endif // JELLYFISHAUDIO_H
 
======================================= 
File: lib\JellyfishAudio\JellyfishAudio.cpp 
======================================= 
#include "JellyfishAudio.h"

// Constructor
AudioOutputI2SWithLevel::AudioOutputI2SWithLevel() 
    : audioLevel(0), currentGain(1.0f) {}

// Override SetGain to store the gain value and call the base class.
bool AudioOutputI2SWithLevel::SetGain(float gain) {
    currentGain = gain;
    return AudioOutputI2S::SetGain(gain);
}

// Getter for the current gain.
float AudioOutputI2SWithLevel::getCurrentGain() const {
    return currentGain;
}

// Override ConsumeSample to apply the gain manually and compute the audio level.
bool AudioOutputI2SWithLevel::ConsumeSample(int16_t sample[2]) {
    // Apply the current gain to both channels.
    sample[0] = (int16_t)(sample[0] * currentGain);
    sample[1] = (int16_t)(sample[1] * currentGain);

    // Compute the audio level for LED updates.
    int16_t left = abs(sample[0]);
    int16_t right = abs(sample[1]);
    audioLevel = (left + right) / 2;

    return AudioOutputI2S::ConsumeSample(sample);
}

// Return the computed audio level.
int AudioOutputI2SWithLevel::getAudioLevel() {
    return audioLevel;
}
 
