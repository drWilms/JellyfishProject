Merged JellyfishProject Code (Generated on 2025-03-12_09-18) 
===================================================== 
======================================= 
File: src\main.cpp 
======================================= 
#include "DynTimer.h"
#include "JellyfishQueue.h"
#include "WiFiManager.h"
#include "config.h"
#include <vector>

/**
 * ======================== Demo4 Specification ========================
 *
 * Main Print Cycle (":" and ";"):
 * - Every 1 second, print ":" 10 times.
 * - Then switch to ";" for 9 times.
 * - Then switch back to ":" for 8 times.
 * - Continue decreasing until 0.
 * - At 0, switch to "." for 10 times, "," for 7 times, following the same decreasing pattern.
 * - This full cycle repeats 7 times.
 *
 * Secondary Print Cycle ("*" and "#"):
 * - Every 45 seconds, print "*" for 5 minutes.
 * - Then switch "*" → "#" for 4 minutes.
 * - Then switch back to "*" for 3 minutes.
 * - This full cycle repeats 13 times.
 *
 * LED Blink Cycle:
 * - LED on PIN 2 blinks with a cycle of 20ms OFF and 17ms ON.
 *
 * WiFi Management:
 * - Connect to WiFi at startup.
 * - Unconditionally reconnect every 6 minutes.
 * - Print connection status updates.
 *
 * Synchronization:
 * - "." and "," follow the same decrementing pattern as ":" and ";".
 * - "*" and "#" operate independently of the ":" and ";" cycle.
 *
 * Queue Management:
 * - All printed characters will be queued in JellyfishQueue before printing.
 *
 * Timer Management:
 * - Uses TimerManager to dynamically allocate and manage timers.
 *
 * End Condition:
 * - The program stops after 11 minutes.
 */

JellyfishQueue eventQueue;
TimerManager timerManager;
WiFiManager wifiManager;

// Print Cycle Control Variables
char currentChar = ':';
int repeatCount = 10;
int mainCycleRepeats = 7;

// Symbol Print Cycle Control Variables
char symbolChar = '*';
int symbolRepeatCount = 5;
int symbolCycleRepeats = 13;

// LED Blink Control Variables
bool ledState = false;
void toggleLED();
int ledBlinkTimerNr;

// Time Control
unsigned long programStartTime;
const unsigned long programDuration = 11 * 60 * 1000;

// Function prototypes
void onMainCycle();
void onSymbolCycle();
void processQueue();
void manageWiFi();

void toggleLED() {
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState);

    DynTimer* ledTimer = timerManager.getTimer(ledBlinkTimerNr);
    if (ledTimer) {
        ledTimer->setInterval(ledState ? 17 : 20);
    }
}

void onMainCycle() {
    if (mainCycleRepeats == 0) return;
    eventQueue.enqueue(std::string(1, currentChar));
    repeatCount--;
    if (repeatCount == 0) {
        switch (currentChar) {
            case ':': currentChar = ';'; repeatCount = 9; break;
            case ';': currentChar = ':'; repeatCount = 8; break;
            case '.': currentChar = ','; repeatCount = 7; break;
            case ',': currentChar = '.'; repeatCount = 10; break;
        }
        if (repeatCount == 10 && currentChar == '.') {
            mainCycleRepeats--;
        }
    }
}

void onSymbolCycle() {
    if (symbolCycleRepeats == 0) return;
    eventQueue.enqueue(std::string(1, symbolChar) + "\n");
    symbolRepeatCount--;
    if (symbolRepeatCount == 0) {
        switch (symbolChar) {
            case '*': symbolChar = '#'; symbolRepeatCount = 4; break;
            case '#': symbolChar = '*'; symbolRepeatCount = 3; break;
        }
        if (symbolRepeatCount == 5 && symbolChar == '*') {
            symbolCycleRepeats--;
        }
    }
}

void processQueue() {
    if (!eventQueue.isEmpty()) {
        std::string event = eventQueue.dequeue();
        Serial.print(event.c_str());
    }
    if (millis() - programStartTime >= programDuration) {
        Serial.println("\n=== Program Ended ===");
        timerManager.stopAll();
    }
}

void manageWiFi() {
    Serial.println("[WiFi] Checking connection...");
    wifiManager.reconnect();
}

void setup() {
    Serial.begin(115200);
    Serial.println("=== Demo4 Start ===");

    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    programStartTime = millis();

    wifiManager.begin();  // Connect to WiFi at startup

    timerManager.addTimer(1000, onMainCycle, true);
    timerManager.addTimer(45000, onSymbolCycle, true);
    timerManager.addTimer(10, processQueue, true);
    ledBlinkTimerNr = timerManager.addTimer(20, toggleLED, true);
    timerManager.addTimer(6 * 60 * 1000, manageWiFi, true); // Reconnect WiFi every 6 minutes
}

void loop() {
    timerManager.updateAll();
} 
======================================= 
Library: lib\config 
======================================= 
======================================= 
File: lib\config\config.h 
======================================= 
/**
 * Jellyfish Project - Fully Restored Codebase with Timer Hierarchy
 * Version: 2025-03-07
 */

// ========================= config.h =========================
#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>
#include "config_secrets.h"

// === Pin Definitions ===
#define LED_PIN         2  // Built-in LED
#define PIN_LED         4  // LED Data Out
#define PIN_I2S_DOUT   14  // I2S Data
#define PIN_I2S_BCLK   13  // I2S Bit Clock
#define PIN_I2S_LRC    15  // I2S Left/Right Clock
#define PIN_SD_CS       5  // SD Card Chip Select

// === LED Configuration ===
#define NUM_LEDS 10
#define LED_TYPE WS2812    // Define LED type
#define LED_RGB_ORDER GRB  // Define RGB order

// === Timer Intervals ===
#define SLOW_TIMER_INTERVAL   1000  // 1 second and above
#define FAST_TIMER_INTERVAL    250  // 100ms - 999ms
#define ULTRAFAST_TIMER_INTERVAL 50 // Below 100ms

// === Global Variables ===
extern int audioLevel;   // Stores real-time audio level
extern bool silentMode;  // True if LEDs should remain off
extern int brightness;   // LED brightness level

#endif  // CONFIG_H 
======================================= 
File: lib\config\config_secrets.h 
======================================= 
#ifndef CONFIG_SECRETS_H
#define CONFIG_SECRETS_H

#define WIFI_SSID "keijebijter"
#define WIFI_PASSWORD "Helmondia'55"

#endif // CONFIG_SECRETS_H
 
======================================= 
File: lib\config\config.cpp 
======================================= 
#include "config.h"

// === Global Variables ===
int audioLevel = 0;
bool silentMode = false;
int brightness = 150;
 
======================================= 
Library: lib\DynTimer 
======================================= 
======================================= 
File: lib\DynTimer\DynTimer.h 
======================================= 
#ifndef DYNTIMER_H
#define DYNTIMER_H

#include <Arduino.h>
#include <functional>
#include <vector>

class DynTimer {
private:
    unsigned long interval;
    unsigned long nextExecution;
    bool repeating;
    bool running;
    bool debugEnabled;
    std::function<void()> callback;

public:
    DynTimer(unsigned long intervalMs, std::function<void()> callback, bool repeating = true);
    void start();
    void stop();
    void pause();
    void resume();
    bool isReady();
    void reset();
    void update();
    void setInterval(unsigned long newInterval);  // ✅ New function

    bool isRunning() const { return running; }
    unsigned long getNextExecution() const { return nextExecution; }
    void setDebug(bool enable);
    bool getDebug() const;
};

class TimerManager {
private:
    std::vector<DynTimer*> timers;

public:
    int addTimer(unsigned long interval, std::function<void()> callback, bool repeating = true);
    void removeTimer(int index);
    void updateAll();
    void stopAll();
    DynTimer* getTimer(int index);  // ✅ New function
};

#endif // DYNTIMER_H
 
======================================= 
File: lib\DynTimer\DynTimer.cpp 
======================================= 
#include "DynTimer.h"
#include <Arduino.h>

// ======================== DynTimer Implementation ========================

DynTimer::DynTimer(unsigned long intervalMs, std::function<void()> callback, bool repeating)
    : interval(intervalMs), callback(callback), repeating(repeating), running(false), nextExecution(0), debugEnabled(false) {}

void DynTimer::start() {
    running = true;
    nextExecution = millis() + interval;
}

void DynTimer::stop() {
    running = false;
}

void DynTimer::pause() {
    running = false;
}

void DynTimer::resume() {
    running = true;
    nextExecution = millis() + interval;
}

bool DynTimer::isReady() {
    return running && millis() >= nextExecution;
}

void DynTimer::reset() {
    nextExecution = millis() + interval;
}

void DynTimer::setInterval(unsigned long newInterval) {
    interval = newInterval;
    reset();
}

void DynTimer::update() {
    if (isReady()) {
        callback();
        if (repeating) {
            reset();
        } else {
            stop();
        }
    }
}

// ======================== TimerManager Implementation ========================

int TimerManager::addTimer(unsigned long interval, std::function<void()> callback, bool repeating) {
    DynTimer* timer = new DynTimer(interval, callback, repeating);
    timers.push_back(timer);
    timer->start();
    return timers.size() - 1;
}

void TimerManager::removeTimer(int index) {
    if (index >= 0 && index < timers.size()) {
        delete timers[index];
        timers.erase(timers.begin() + index);
    }
}

void TimerManager::updateAll() {
    for (auto& timer : timers) {
        timer->update();
    }
}

void TimerManager::stopAll() {
    for (auto& timer : timers) {
        delete timer;
    }
    timers.clear();
}

DynTimer* TimerManager::getTimer(int index) {
    if (index >= 0 && index < timers.size()) {
        return timers[index];
    }
    return nullptr;
}
 
======================================= 
File: lib\DynTimer\keywords.txt 
======================================= 
DynTimer     KEYWORD1
start        KEYWORD2
isReady      KEYWORD2
reset        KEYWORD2
pause        KEYWORD2
resume       KEYWORD2
addTimer     KEYWORD2
update       KEYWORD2
isRunning    FUNCTION
 
======================================= 
Library: lib\JellyfishLEDs 
======================================= 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.h 
======================================= 
 
// Updated: 2025-03-11 07:30:00 
#ifndef JELLYFISHLEDS_H 
#define JELLYFISHLEDS_H 
#include <FastLED.h> 
#include "config.h" 
class JellyfishLEDs { 
private: 
CRGB leds[NUM_LEDS]; 
public: 
JellyfishLEDs(); 
void init(); 
void setSingleColor(int index, CRGB color); 
void runRainbow(); 
}; 
#endif // JELLYFISHLEDS_H 
 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.cpp 
======================================= 
 
// Updated: 2025-03-11 07:30:00 
#include "JellyfishLEDs.h" 
JellyfishLEDs::JellyfishLEDs() { 
FastLED.addLeds<LED_TYPE, LED_PIN, LED_RGB_ORDER>(leds, NUM_LEDS); 
FastLED.clear(); 
} 
void JellyfishLEDs::init() { 
FastLED.clear(); 
FastLED.show(); 
} 
void JellyfishLEDs::setSingleColor(int index, CRGB color) { 
if (index >= 0 && index < NUM_LEDS) { 
leds[index] = color; 
FastLED.show(); 
} 
} 
void JellyfishLEDs::runRainbow() { 
static uint8_t hue = 0; 
for (int i = 0; i < NUM_LEDS; i++) { 
leds[i] = CHSV(hue + (i * 10), 255, 255); 
} 
FastLED.show(); 
hue += 5; 
} 
 
======================================= 
File: lib\JellyfishLEDs\keywords.txt 
======================================= 
 
// Updated: 2025-03-11 07:30:00 
JellyfishLEDs   KEYWORD1 
setSingleColor  KEYWORD2 
updateLEDs      KEYWORD2 
clearLEDs       KEYWORD2 
// END OF GPT UPDATE FILE 
 
======================================= 
Library: lib\JellyfishQueue 
======================================= 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.h 
======================================= 
#ifndef JELLYFISHQUEUE_H
#define JELLYFISHQUEUE_H

#include <queue>
#include <string>
#include <Arduino.h>

class JellyfishQueue {
private:
    std::queue<std::string> queue;
    bool DebugJellyfishQueue;  // Debug flag

public:
    JellyfishQueue();

    void enqueue(const std::string& item);
    std::string dequeue();
    std::string peek() const;
    bool isEmpty() const;
    void clear();
    size_t size() const;

    // Debug control
    void setDebug(bool enable);
    bool getDebug() const;
};

#endif // JELLYFISHQUEUE_H
 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.cpp 
======================================= 
#include "JellyfishQueue.h"

JellyfishQueue::JellyfishQueue() : DebugJellyfishQueue(false) {}

void JellyfishQueue::enqueue(const std::string& item) {
    queue.push(item);
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] Enqueued: %s at %lu ms\n", item.c_str(), millis());
    }
}

std::string JellyfishQueue::dequeue() {
    if (queue.empty()) {
        if (DebugJellyfishQueue) {
            Serial.printf("[JellyfishQueue] Dequeue attempted on empty queue at %lu ms\n", millis());
        }
        return "";
    }
    std::string item = queue.front();
    queue.pop();
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] Dequeued: %s at %lu ms\n", item.c_str(), millis());
    }
    return item;
}

std::string JellyfishQueue::peek() const {
    if (queue.empty()) {
        if (DebugJellyfishQueue) {
            Serial.printf("[JellyfishQueue] Peek attempted on empty queue at %lu ms\n", millis());
        }
        return "";
    }
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] Peek: %s at %lu ms\n", queue.front().c_str(), millis());
    }
    return queue.front();
}

bool JellyfishQueue::isEmpty() const {
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] isEmpty check: %s at %lu ms\n", queue.empty() ? "true" : "false", millis());
    }
    return queue.empty();
}

void JellyfishQueue::clear() {
    while (!queue.empty()) {
        queue.pop();
    }
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] Cleared at %lu ms\n", millis());
    }
}

size_t JellyfishQueue::size() const {
    if (DebugJellyfishQueue) {
        Serial.printf("[JellyfishQueue] Size check: %lu at %lu ms\n", queue.size(), millis());
    }
    return queue.size();
}

// Debug control
void JellyfishQueue::setDebug(bool enable) {
    DebugJellyfishQueue = enable;
    Serial.printf("[JellyfishQueue] Debug mode %s at %lu ms\n", DebugJellyfishQueue ? "enabled" : "disabled", millis());
}

bool JellyfishQueue::getDebug() const {
    return DebugJellyfishQueue;
}
 
======================================= 
File: lib\JellyfishQueue\keywords.txt 
======================================= 
# Keywords for JellyfishQueue
JellyfishQueue  KEYWORD1
enqueue         KEYWORD2
dequeue         KEYWORD2
isEmpty         KEYWORD2
clear           KEYWORD2
 
WARNING: lib\JellyfishAudio not found Skipping... 
======================================= 
Library: lib\WiFiManager 
======================================= 
======================================= 
File: lib\WiFiManager\WiFiManager.h 
======================================= 
#ifndef WIFI_MANAGER_H
#define WIFI_MANAGER_H

#include <WiFi.h>
#include "config.h"

class WiFiManager {
public:
    WiFiManager();
    void begin();       // Connects to WiFi at startup
    void reconnect();   // Reconnects every 6 minutes
    bool isConnected(); // Returns true if connected
};

#endif // WIFI_MANAGER_H
 
======================================= 
File: lib\WiFiManager\WiFiManager.cpp 
======================================= 
#include "WiFiManager.h"
#include <Arduino.h>

WiFiManager::WiFiManager() : debugWiFi(true) {}  // Default: Debug enabled

void WiFiManager::begin() {
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    if (debugWiFi) Serial.print("[WiFi] Connecting");

    unsigned long startAttemptTime = millis();  // Timeout counter
    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 10000) {  // 10s timeout
        delay(500);
        if (debugWiFi) Serial.print(".");
    }

    if (WiFi.status() == WL_CONNECTED) {
        if (debugWiFi) Serial.println("\n[WiFi] Connected: " + WiFi.localIP().toString());
    } else {
        if (debugWiFi) Serial.println("\n[WiFi] Connection FAILED, will retry in 6 min.");
    }
}

void WiFiManager::reconnect() {
    if (debugWiFi) Serial.println("[WiFi] Reconnecting...");
    WiFi.disconnect();
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}

bool WiFiManager::isConnected() {
    return WiFi.status() == WL_CONNECTED;
}

void WiFiManager::setDebug(bool enable) {
    debugWiFi = enable;
    Serial.printf("[WiFi] Debug mode %s.\n", debugWiFi ? "enabled" : "disabled");
}

bool WiFiManager::getDebug() const {
    return debugWiFi;
}
 
======================================= 
File: lib\WiFiManager\keywords.txt 
======================================= 
 
