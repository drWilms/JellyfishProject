Merged JellyfishProject Code (Generated on 2025-03-11_07-14) 
===================================================== 
======================================= 
File: src\main.cpp 
======================================= 
#include <Arduino.h>
#include "DynTimer.h"
#include "config.h"

void toggleOnboardLED() {
    static bool state = false;
    state = !state;
    digitalWrite(LED_PIN, state);
    Serial.printf("Toggling Onboard LED at %lu ms\n", millis());
}

DynTimer ledTimer(1000, toggleOnboardLED, true); // Create LED timer

void setup() {
    Serial.begin(115200);
    Serial.println("DynTimer Multi-Timer Test Started");

    pinMode(LED_PIN, OUTPUT);

    DynTimer::addTimer(&ledTimer); // Register LED timer
}

void loop() {
    DynTimer::update(); // Properly check & execute timers
}
 
======================================= 
Library: lib\config 
======================================= 
======================================= 
File: lib\config\config.h 
======================================= 
/**
 * Jellyfish Project - Fully Restored Codebase with Timer Hierarchy
 * Version: 2025-03-07
 */

// ========================= config.h =========================
#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>
#include "config_secrets.h"

// === Pin Definitions ===
#define LED_PIN         2  // Built-in LED
#define PIN_LED         4  // LED Data Out
#define PIN_I2S_DOUT   14  // I2S Data
#define PIN_I2S_BCLK   13  // I2S Bit Clock
#define PIN_I2S_LRC    15  // I2S Left/Right Clock
#define PIN_SD_CS       5  // SD Card Chip Select

// === LED Configuration ===
#define NUM_LEDS 10
#define LED_TYPE WS2812    // Define LED type
#define LED_RGB_ORDER GRB  // Define RGB order

// === Timer Intervals ===
#define SLOW_TIMER_INTERVAL   1000  // 1 second and above
#define FAST_TIMER_INTERVAL    250  // 100ms - 999ms
#define ULTRAFAST_TIMER_INTERVAL 50 // Below 100ms

// === Global Variables ===
extern int audioLevel;   // Stores real-time audio level
extern bool silentMode;  // True if LEDs should remain off
extern int brightness;   // LED brightness level

#endif  // CONFIG_H 
======================================= 
File: lib\config\config_secrets.h 
======================================= 
#ifndef CONFIG_SECRETS_H
#define CONFIG_SECRETS_H

#define WIFI_SSID "keijebijter"
#define WIFI_PASSWORD "Helmondia'55"

#endif // CONFIG_SECRETS_H
 
======================================= 
File: lib\config\config.cpp 
======================================= 
#include "config.h"

// === Global Variables ===
int audioLevel = 0;
bool silentMode = false;
int brightness = 150;
 
======================================= 
Library: lib\DynTimer 
======================================= 
======================================= 
File: lib\DynTimer\DynTimer.h 
======================================= 
#ifndef DYNTIMER_H
#define DYNTIMER_H

#include <Arduino.h>
#include <functional>
#include <vector>

class DynTimer {
private:
    unsigned long interval;
    unsigned long nextExecution;
    unsigned long pauseRemaining = 0;
    bool repeating;
    bool running;
    std::function<void()> callback;

    static std::vector<DynTimer*> activeTimers; // Stores all timers

public:
    DynTimer(unsigned long intervalMs, std::function<void()> callback, bool repeating = true);
    void start();
    void pause();
    void resume();
    bool isReady();
    void reset();

    static void addTimer(DynTimer* timer); // Restore this function
    static void update(); // Fix update function to work with stored timers
};

#endif // DYNTIMER_H
 
======================================= 
File: lib\DynTimer\DynTimer.cpp 
======================================= 
#include "DynTimer.h"
#include <Arduino.h>

std::vector<DynTimer*> DynTimer::activeTimers; // Store timers globally

DynTimer::DynTimer(unsigned long intervalMs, std::function<void()> callback, bool repeating)
    : interval(intervalMs), callback(callback), repeating(repeating), running(true) {
    nextExecution = millis() + interval;
}

void DynTimer::start() {
    running = true;
    nextExecution = millis() + interval;
}

void DynTimer::pause() {
    if (running) {
        pauseRemaining = nextExecution - millis();
        running = false;
        Serial.printf("Timer PAUSED at %lu ms\n", millis());
    }
}

void DynTimer::resume() {
    if (!running) {
        nextExecution = millis() + pauseRemaining;
        running = true;
        Serial.printf("Timer RESUMED at %lu ms\n", millis());
    }
}

bool DynTimer::isReady() {
    if (!running) return false;  // Ensure execution stops when paused
    if (millis() >= nextExecution) {
        callback();
        if (repeating) {
            nextExecution = millis() + interval;  // Reset next execution time
        }
        return true;
    }
    return false;
}

void DynTimer::reset() {
    nextExecution = millis() + interval;
}

void DynTimer::addTimer(DynTimer* timer) {
    activeTimers.push_back(timer); // Dynamically add timers
}

void DynTimer::update() {
    for (auto it = activeTimers.begin(); it != activeTimers.end();) {
        DynTimer* timer = *it;
        if (timer->isReady()) {
            if (!timer->repeating) {
                it = activeTimers.erase(it); // Remove non-repeating timers
            } else {
                ++it;
            }
        } else {
            ++it;
        }
    }
}
 
======================================= 
File: lib\DynTimer\keywords.txt 
======================================= 
DynTimer     KEYWORD1
start        KEYWORD2
isReady      KEYWORD2
reset        KEYWORD2
pause        KEYWORD2
resume       KEYWORD2
addTimer     KEYWORD2
update       KEYWORD2
isRunning    FUNCTION
 
======================================= 
Library: lib\JellyfishLEDs 
======================================= 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.h 
======================================= 
#ifndef JELLYFISHLEDS_H
#define JELLYFISHLEDS_H

#include <FastLED.h>
#include "config.h"

class JellyfishLEDs {
private:
    CRGB leds[NUM_LEDS];

public:
    JellyfishLEDs();
    void init();
    void setSingleColor(int index, CRGB color);
    void runRainbow();
};

#endif // JELLYFISHLEDS_H
 
======================================= 
File: lib\JellyfishLEDs\JellyfishLEDs.cpp 
======================================= 
#include "JellyfishLEDs.h"

JellyfishLEDs::JellyfishLEDs() {
    FastLED.addLeds<LED_TYPE, LED_PIN, LED_RGB_ORDER>(leds, NUM_LEDS);
    FastLED.clear();
}

void JellyfishLEDs::init() {
    FastLED.clear();
    FastLED.show();
}

void JellyfishLEDs::setSingleColor(int index, CRGB color) {
    if (index >= 0 && index < NUM_LEDS) {
        leds[index] = color;
        FastLED.show();
    }
}

void JellyfishLEDs::runRainbow() {
    static uint8_t hue = 0;
    for (int i = 0; i < NUM_LEDS; i++) {
        leds[i] = CHSV(hue + (i * 10), 255, 255);
    }
    FastLED.show();
    hue += 5;
} 
======================================= 
File: lib\JellyfishLEDs\keywords.txt 
======================================= 
# Keywords for JellyfishLEDs
JellyfishLEDs   KEYWORD1
setSingleColor  KEYWORD2
updateLEDs      KEYWORD2
clearLEDs       KEYWORD2
 
======================================= 
Library: lib\JellyfishQueue 
======================================= 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.h 
======================================= 
// ========================= JellyfishQueue.h =========================
#ifndef JELLYFISHQUEUE_H
#define JELLYFISHQUEUE_H

#include <queue>
#include <string>
#include <Arduino.h>

class JellyfishQueue {
private:
    std::queue<std::string> queue;

public:
    void enqueue(const std::string& item);
    std::string dequeue();
    std::string peek() const;
    bool isEmpty() const;
    void clear();
    size_t size() const;
};

#endif // JELLYFISHQUEUE_H 
======================================= 
File: lib\JellyfishQueue\JellyfishQueue.cpp 
======================================= 
// ========================= JellyfishQueue.cpp =========================
#include "JellyfishQueue.h"

void JellyfishQueue::enqueue(const std::string& item) {
    queue.push(item);
}

std::string JellyfishQueue::dequeue() {
    if (queue.empty()) return "";
    std::string item = queue.front();
    queue.pop();
    return item;
}

std::string JellyfishQueue::peek() const {
    return queue.empty() ? "" : queue.front();
}

bool JellyfishQueue::isEmpty() const {
    return queue.empty();
}

void JellyfishQueue::clear() {
    while (!queue.empty()) {
        queue.pop();
    }
}

size_t JellyfishQueue::size() const {
    return queue.size();
} 
======================================= 
File: lib\JellyfishQueue\keywords.txt 
======================================= 
# Keywords for JellyfishQueue
JellyfishQueue  KEYWORD1
enqueue         KEYWORD2
dequeue         KEYWORD2
isEmpty         KEYWORD2
clear           KEYWORD2
 
WARNING: lib\JellyfishAudio not found Skipping... 
